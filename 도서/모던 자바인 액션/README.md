# 15장 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

## 15.1.2 Executor와 스레드 풀
자바 5는 Executor 프레임워크와 스레드 풀을 통해 스레드의 힘을 높은 수준으로 끌어올리는 즉 자바
프로그래머가 태스크 제출과 실행을 분리할 수 있는 기능을 제공

### 스레드의 문제
자바 스레드는 직접 운영체제 스레드에 접근한다.

운영 체제 스레드를 생성 종려하는데 비싼 비용이 든다.

운영 체제가 지원하는 스레드 수를 초과해서 사용하면 자바 애플리케이션이 크래시 될 수 있다.

### 스레드 풀이 더 좋은 이유
ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공한다.

제출된 태스크를 먼저 온 순서대로 실행한다. 이 방식의 장점은 하드웨어의 맞는 수의 태스크를 유지 하면서 수 천개의 태스크를 
스레드 풀에 아무 오버헤드 없이 제출할 수 있다는 장점이 있다.

프로그래머는 태스크(Runnable, Callable)를 제공하면 스레드가 이를 실행

### 스레드 풀이 나쁜 이유
- I/O를 기다리는 등의 블로킹 상태의 스레드에 주의 해야한다. 
20개의 태스크, 5개의 스레드 가 있으면 3개가 블로킹 되었다면 2개로 15개의 태스크를 처리해야한다.
- 중요한 코드를 실행하는 스레드가 죽는 일이 없도록 main이 반환되기전에 모든 스레드의 작업을 종료한다.

# 15.2 동기 그리고 비동기 API

## 15.2.2 리액티브 형식의 API
콜백 형식의 프로그래밍을 이용

리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도록 설계되었으므로 Future를 이용하는 것이 적절하다.

## 15.2.3 잠자기(기타 블로킹 동작)는 해로운 것으로 간주
스레드는 블로킹 시 시스템 자원을 점유한다.

스레드 풀에서 잠을 자는 태스크는 다른 태스크가 시작되지 못하게 막아 자원을 소비한다.

## 비동기 api 와 동시성 api

- 비동기
작업 요청 후 결과를 기다리지 않고 바로 반환함

- 동시성
여러 작업을 동시에 실행할 수 있게 해주는 API

## 15.3 박스와 채널 모델
Future의 get()을 할때 blocking이 일어나는데, 이 작업이 대규모 작업이면 하드웨어의 병렬성을 제대로 활용하기 쉽지 않다.

이를 CompletableFuture와 콤비네이터를 이용해 문제를 해결한다.

## 15.4 CompletableFuture와 콤비네이터를 이용한 동시성
자바 8에서는 Future 인터페이스의 구현인 CompletableFuture를 이용해 Future를 조합할 수 있는 기능을 추가했다.

## 15.5. 발행- 구독 그리고 리액티브 프로그래밍
Future와 CompletableFuture은 독립적 실행과 병령성이라는 정식적 모델에 기반하며 Future는 한 번만 실행해 결과를 제공한다.

반면 리액티브 프로그래밍은 시간이 흐르면서 Future 같은 객체를 통해 여러 결과를 제공한다.

예시) <br>
온도계 객체(매 초마다 온도 값을 반복적으로 제공), 리스너 객체(Http 요청을 기다렸다가 이후에 결과를 생산)

이 두 객체를 처리하는 객체  하나가 있다.

자바 9에서는 Flow의 인터페스에 발행-구독 모델을 적용해 리액티브 프로그래밍을 제공한다.
- 구독자가 구독할 수 있는 발행자
- 이 연결을 구독이라 한다.
- 이 연결을 이용해 메시지를 전송한다.

<? super T> 는 쓰기 일때 값을 외부로부터 넣을 때 (Consumer), <? extends T> 읽기 전용 값을 외부에서 꺼낼 때 (Producer)

onNext는 데이터를 전달하는 용도 업스트림, 다운 스트림

## 역압력
Subscriber 객체를 어떻게 어떻게 Publisher에게 전달해 발행자가 필요한 메서드를 호출할 수 있는지 살펴봤다.

