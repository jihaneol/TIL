# 1장 객체 설계
로버트 L 글래스는 이론보다 실무가 먼저라고 주장했다.<br>
이론보다 실무가 앞서가 있는 분야는 소프트웨어 설계와 유지보수 이다. <br>
소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적이다.

## 01. 티켓 판매 애플리케이션 구현하기
티켓, 초대장, 관객, 가방, 극장, 티켓 부스, 티켓 판매자 생성했다.<br>
현실에 있는 절차대로 객체를 만들고 절차적으로 티켓 수령을 작성했다. 하지만 이 프로그램은 문제가 있다. 무엇일까?

## 02. 무엇이 문제인가.
로버트 마틴은 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다. <br>
1. 실행 중에 제대로 동작하는 것.
2. 변경이 용이해야 한다.
3. 코드를 읽는 사람과 소통하는 것. (이해하기 쉬워야 한다.)

티켓 프로그램은 2,3을 만족 시키지 못한다.

### 예상을 빗나가는 코드
문제의 첫번째는 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점이다.<br>
현실에서는 관람객이 직접 자신의 가방에서 초대장을 꺼내는 등 직접 행동을 하지만 코드에서는 그렇게 하지 않는다.

두번째 문제는 코드를 이해하려면 여러 세부적인 내용을 알아야 한다. 예로 Theater의 enter 메서드에는 Audience, bag, TicketOffice등등 많다.
이 처럼 하나의 클래스나 메소드가 너무 많은 세부사항을 다룬다.

마지막으로 가장 심각한 것은 Audience와 TicketSeller를 변경하면 Theater도 변경된다.

### 변경에 취약한 코드
예를 들어보자 가방에서 물건을 꺼내는 코드에서 가방이 아닌 핸드백, 책가방 등 바뀌고, 현금이 아닌 신용카드 쿠폰으로 바뀐다면 모든 코드를 수정하는 변경에 취약한 코드이다.

이것은 객체 사이의 의존성과 관련된 문제다. 의존성은 변경에 대한 영향을 암시한다.<br>
의존성이 과한 경우를 결합도가 높다고 말한다. 결론적으로 결합도를 낮춰 변경이 용이한 설계를 만들어야 한다.

## 03. 설계 개선하기
코드를 보면 문제의 원인은 Theater가 직접 Audiece와 TicketSeller를 접근한다는 것이다. 결론적으로 관람객과 판매원을 자율적인 존재로 만들면된다.

### 자율성을 높이자
자율성을 높이는 방법
1. TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨긴다.<br>
getTicketOffice가 사라지고 외부에서는 ticketOffice에 직접 접근할 수 없다.
이 처럼 객체 내부의 사항을 감추는 것을 캡슐화라고 부른다.<br>

캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다. 내부로의 접근을 제한하면 객체와 객체 사이에 결합도를 낮출 수 있기 때문이다.

2. Bag에 접근하는 모든 코드를 Audience 내부로 숨긴다.

### 무엇이 개선됐는가.
자율적인 존재로 만들어서 Audience와 TicketSeller의 내부 구현을 변경하더라도 Theater를 함께 변경할 필요가 없어졌다.

### 어떻게 한것인가.
기존의 Theater에서 직접 접근했던 내부 코드를 실제 사용하고 있는 Audience와 TicketSeller 내부로 코드를 옮겼다.

### 캐슐화의 응집도
객체의 내부의 상태를 캐슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.<br>
밀접하게 관련된 작업만을 수행하고 다른 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.

외부의 간섭을 최대한 배체하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 휼륭한 객체지향 설계를 얻을 수 있는 지름길이다.

### 절차지향과 객체지향
절차적 관점에서 봤을때 Theater의 enter 메서드는 프로세스 이며 Audience, TicketSeller 등은 데이터이다.<br>
이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 한다.

절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수밖에 없다.

해결 방법은 자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 Audience와 TicketSeller로 이동시키는 것이다.<br>
데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 부른다.

객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.

### 책임의 이동
초기 Theater에 몰려있던 책임이 개별 객체로 이동한 것. 이것이 책임의 이동이다.
객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다. 따라서 데이터보다는 어떤 책임을 할당할 것이냐에
초점을 맞춰야 한다.

>설계를 어렵게 만드는 것은 '의존성' -> 해결법은 의존성을 제거하여 '결합도'를 낮추는 것
> -> 결합도를 낮추는 방법은 '캡슐화' -> 결과적으로 객체의 '자율성'을 높이고 '응집도' 높은 객체 생성
> -> 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계다.

### 더 개선할 수 있다.
1. Audience의 Bag을 위와 같은 방식으로 캡슐화하여 스스로 책임질 수 있게 개선하자. 
2. TicketOffice에서 get을 사용하여 Ticket에 접근하고 있다. 개선하자.

2번을 진행한 결과 TicketOffice가 Audiece에 대해 전체적으로 의존성이 증가했다. 이 결과를 통해 두 가지 사실을 발견했다.
1. 어떤 기능을 설계하는 방법은 한가지 이상일 수 있다.
2. 동일한 기능을 한 가지 이상으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다.

> 설계는 균형의 예술이다. 훌륭한 설계는 적절한 트레이드오프의 결과물이다.

## 04. 객체지향 설계
### 설계가 왜 필요한가.
> 설계란 코드를 배치하는 것이다.

좋은 설계란 오늘 요구하는 기능을 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.

변경을 수용할 수 있는 설계가 중요한 이유
1. 요구사항은 바뀔 수 밖에 없다.
2. 코드를 변경할 때 버그가 추가될 가능성이 높다.

### 객체지향 설계
변경에 유연하게 대응할 수 있는 코드, 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 방법을 제공한다.
1. 이해하기 쉬운 코드
2. 자신의 데이터를 스스로 책임지는 자율적인 존재
3. 객체간의 상호작용

협력하는 객체 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설게를 만드는 것이다.


# 2장 객체지향 프로그래밍



## 믹스인
객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법

상속이 클래스와 클래스 사이의 관계를 고정시키는 데 비해 믹스인은 유연하게 관계를 재구성한다.

합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용할 수 있는 방법이다.

### 기본 정책 구현하기
기본 정책을 구현 후 부가 정책과 관련된 코드를 기본 정책에 어떻게 믹스인할 수 있는지 고민.
