# 1장 객체 설계
로버트 L 글래스는 이론보다 실무가 먼저라고 주장했다.<br>
이론보다 실무가 앞서가 있는 분야는 소프트웨어 설계와 유지보수 이다. <br>
소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적이다.

## 01. 티켓 판매 애플리케이션 구현하기
티켓, 초대장, 관객, 가방, 극장, 티켓 부스, 티켓 판매자 생성했다.<br>
현실에 있는 절차대로 객체를 만들고 절차적으로 티켓 수령을 작성했다. 하지만 이 프로그램은 문제가 있다. 무엇일까?

## 02. 무엇이 문제인가.
로버트 마틴은 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다. <br>
1. 실행 중에 제대로 동작하는 것.
2. 변경이 용이해야 한다.
3. 코드를 읽는 사람과 소통하는 것. (이해하기 쉬워야 한다.)

티켓 프로그램은 2,3을 만족 시키지 못한다.

### 예상을 빗나가는 코드
문제의 첫번째는 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점이다.<br>
현실에서는 관람객이 직접 자신의 가방에서 초대장을 꺼내는 등 직접 행동을 하지만 코드에서는 그렇게 하지 않는다.

두번째 문제는 코드를 이해하려면 여러 세부적인 내용을 알아야 한다. 예로 Theater의 enter 메서드에는 Audience, bag, TicketOffice등등 많다.
이 처럼 하나의 클래스나 메소드가 너무 많은 세부사항을 다룬다.

마지막으로 가장 심각한 것은 Audience와 TicketSeller를 변경하면 Theater도 변경된다.

### 변경에 취약한 코드
예를 들어보자 가방에서 물건을 꺼내는 코드에서 가방이 아닌 핸드백, 책가방 등 바뀌고, 현금이 아닌 신용카드 쿠폰으로 바뀐다면 모든 코드를 수정하는 변경에 취약한 코드이다.

이것은 객체 사이의 의존성과 관련된 문제다. 의존성은 변경에 대한 영향을 암시한다.<br>
의존성이 과한 경우를 결합도가 높다고 말한다. 결론적으로 결합도를 낮춰 변경이 용이한 설계를 만들어야 한다.

## 03. 설계 개선하기
코드를 보면 문제의 원인은 Theater가 직접 Audiece와 TicketSeller를 접근한다는 것이다. 결론적으로 관람객과 판매원을 자율적인 존재로 만들면된다.

### 자율성을 높이자
자율성을 높이는 방법
1. TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨긴다.<br>
getTicketOffice가 사라지고 외부에서는 ticketOffice에 직접 접근할 수 없다.
이 처럼 객체 내부의 사항을 감추는 것을 캡슐화라고 부른다.<br>

캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다. 내부로의 접근을 제한하면 객체와 객체 사이에 결합도를 낮출 수 있기 때문이다.

2. Bag에 접근하는 모든 코드를 Audience 내부로 숨긴다.

### 무엇이 개선됐는가.
자율적인 존재로 만들어서 Audience와 TicketSeller의 내부 구현을 변경하더라도 Theater를 함께 변경할 필요가 없어졌다.

### 어떻게 한것인가.
기존의 Theater에서 직접 접근했던 내부 코드를 실제 사용하고 있는 Audience와 TicketSeller 내부로 코드를 옮겼다.

### 캐슐화의 응집도
객체의 내부의 상태를 캐슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.<br>
밀접하게 관련된 작업만을 수행하고 다른 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.

외부의 간섭을 최대한 배체하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 휼륭한 객체지향 설계를 얻을 수 있는 지름길이다.

### 절차지향과 객체지향
절차적 관점에서 봤을때 Theater의 enter 메서드는 프로세스 이며 Audience, TicketSeller 등은 데이터이다.<br>
이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 한다.

절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수밖에 없다.

해결 방법은 자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 Audience와 TicketSeller로 이동시키는 것이다.<br>
데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 부른다.

객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.

### 책임의 이동
초기 Theater에 몰려있던 책임이 개별 객체로 이동한 것. 이것이 책임의 이동이다.
객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다. 따라서 데이터보다는 어떤 책임을 할당할 것이냐에
초점을 맞춰야 한다.

>설계를 어렵게 만드는 것은 '의존성' -> 해결법은 의존성을 제거하여 '결합도'를 낮추는 것
> -> 결합도를 낮추는 방법은 '캡슐화' -> 결과적으로 객체의 '자율성'을 높이고 '응집도' 높은 객체 생성
> -> 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것이 훌륭한 객체지향 설계다.

### 더 개선할 수 있다.
1. Audience의 Bag을 위와 같은 방식으로 캡슐화하여 스스로 책임질 수 있게 개선하자. 
2. TicketOffice에서 get을 사용하여 Ticket에 접근하고 있다. 개선하자.

2번을 진행한 결과 TicketOffice가 Audiece에 대해 전체적으로 의존성이 증가했다. 이 결과를 통해 두 가지 사실을 발견했다.
1. 어떤 기능을 설계하는 방법은 한가지 이상일 수 있다.
2. 동일한 기능을 한 가지 이상으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다.

> 설계는 균형의 예술이다. 훌륭한 설계는 적절한 트레이드오프의 결과물이다.

## 04. 객체지향 설계
### 설계가 왜 필요한가.
> 설계란 코드를 배치하는 것이다.

좋은 설계란 오늘 요구하는 기능을 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.

변경을 수용할 수 있는 설계가 중요한 이유
1. 요구사항은 바뀔 수 밖에 없다.
2. 코드를 변경할 때 버그가 추가될 가능성이 높다.

### 객체지향 설계
변경에 유연하게 대응할 수 있는 코드, 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 방법을 제공한다.
1. 이해하기 쉬운 코드
2. 자신의 데이터를 스스로 책임지는 자율적인 존재
3. 객체간의 상호작용

협력하는 객체 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설게를 만드는 것이다.


# 2장 객체지향 프로그래밍
## 01. 영화 예매 시스템
영화, 상영, 할인 정책(금액, 비율), 할인 조건(순번, 기간)

## 02. 객체지향 프로그래밍을 향해
### 협력, 객체, 클래스
클래스가 아닌 객체에 초점을 맞춰야한다. 두 가지에 집중하자.
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민
2. 독립적인 존재가 아닌 협력하는 공동체의 일원으로 봐야 한다.

### 도메인의 구조를 따르는 프로그램 구조
ERD 설계랑 비슷한 것 같다. 영화는 여러번 상영 되니 Screening N : 1 Movie <br>
상영 영화는 여러번 예매 가능하니 Screening 1 : N Reservation 

### 클래스 구현하기
영화 객체 만들기

#### 자율적인 객체
1. 상태와 행동을 가진 복합적인 존재
2. 객체가 스스로 판단하고 행동하는 자율적인 존재

데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 부른다.
더나아가 접근 제어 메커니즘을 제공, 접근 수정자(public, protected, private)를 제공한다.

접근을 통제하는 이유는 자율적인 존재를 만들기 위해서다.

캐슐화와 접근 제어는 객체를 두 부분으로 나눈다.
1. 외부에서 접근 가능한 퍼블릭 인터페이스
2. 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 구현

인터페이스와 구현의 분리원칙은 훌륭한 객체지향 프로그래밍을 만드는 핵심 원칙이다.

#### 프로그래머의 자유
클래스 작성자: 새로운 데이터 타입을 프로그램에 추가 <br>
클라이언트 프로그래머: 클래스 작성자가 추가한 데이터 타입을 사용

구현 은닉: 클래스 작성자가 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨서 내부 구현을 마음대로 변경할 수 있다.

객체의 변경을 관리할 수 있는 가장 대표적인 것이 바로 접근 제어다. 
private 영역에 변경될 가능성이 있는 세부적인 내용을 감춤으로써 변경으로 인한 혼란을 최소화할 수 있다.

### 협력하는 객체들의 공동체

## 03. 할인 요금 구하기
영화 객체는 요금 계산할 때 할인 정책에게 상영 정보를 주며 계산 하도록 메시지를 전송.

객체지향에서 중요하다고 여겨지는 상속, 다형성 그리고 그 기반에는 추상화라는 원리가 숨겨져 있다.

### 할인 정책과 할인 조건
추상 메서드를 사용, 부모 클래스에 기본적인 알고리즘을 구현하고 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴이라고 부른다.

## 04. 상속과 다형성
Movie 클래스 어디에서도 할인 정책이 무슨 정책인지 판단하지 않는다.
### 컴파일 시간 의존성과 실행 시간 의존성
코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어렵지만 더 유연해지고 확장 가능해진다.

### 차이에 의한 프로그래밍
부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법 - 상속

### 상속과 인터페이스
자식 클래스가 부모 클래스의 타입으로 변환되는 업캐스팅

### 다형성
메시지와 메서드는 다르다. Movie가 Policy에게 보내는 것이 메시지이고 실제 실행되는 것이 메서드이다. 그러므로 메서드는 변경이 될 수 있다.
메시지는 그대로인데 실행되는 메서드가 변경되는 것을 다형성이라고 부른다.

메지시와 메서드를 실행 시점에 바인딩 한다 -> 지연 바인딩 또는 동적 바인딩

## 05. 추상화와 유연성
1. 추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
2. 기존 구조를 수정하기 않고도 새로운 기능을 추가하고 확장할 수 있다.

### 유연한 설계
영화에 정책이 없을 수 있다. 이럴 때 if문을 사용하여 처리하면 변경이 가해진 것이다. 이러지 말고 NonDicountPolicy를 추가하면 된다.<br>
이렇게 하면 변경 없이 추가가 된다. 
> 유연성이 필요한 곳에 추상화를 사용하라.

### 추상 클래스와 인터페이스 트레이드 오프
기존의 NoneDiscountPolicy에서는 getDiscountAmount를 구현하는데 기본적으로 조건이 없다면 실행이 안되니 0원이다.
그러므로 인터페이스로 변경하여 calculateDiscountAmount를 오버라이딩하게 두자.

구현과 관련된 것은 모든 것이 트레이드 오프다.

### 코드 재사용
상속 vs 합성
>왜 합성이 더 좋은가?

### 상속
상속의 제일 문제는 캡슐화를 위배하는 것이다. 
1. 결합이 강하기 때문에 변경하는 것이 어렵다.
2. 컴파일 시점에 결정하여 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.

인스턴스 변수로 관계를 연결한 원래의 설계가 더 유연하다. set을 활용하여 원하는 객체로 변경이 가능하기 때문이다. 이런 용어를 합성이라고 한다.

### 합성
인터페이스를 통해 상속보다 약하게 결합이 된다.

> 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게
> 적절한 책임을 할당하는 것이다.

# 3장 역할, 책임, 협력
## 믹스인
객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법

상속이 클래스와 클래스 사이의 관계를 고정시키는 데 비해 믹스인은 유연하게 관계를 재구성한다.

합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용할 수 있는 방법이다.

### 기본 정책 구현하기
기본 정책을 구현 후 부가 정책과 관련된 코드를 기본 정책에 어떻게 믹스인할 수 있는지 고민.
